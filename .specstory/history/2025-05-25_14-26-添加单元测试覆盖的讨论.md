<!-- Generated by SpecStory -->

# æ·»åŠ å•å…ƒæµ‹è¯•è¦†ç›–çš„è®¨è®º (2025-05-25 22:26:20)

_**User**_

é˜…è¯»  @DESIGN.md  çš„å†…å®¹ï¼Œä¸ºé¡¹ç›®æ·»åŠ å¿…è¦çš„å•å…ƒæµ‹è¯•è¦†ç›–ï¼Œå°¤å…¶æ˜¯ MVC ä¸­çš„ C å®ç°éƒ¨åˆ†ã€‚

---

_**Assistant**_

æˆ‘æ¥ä¸ºé¡¹ç›®æ·»åŠ å¿…è¦çš„å•å…ƒæµ‹è¯•è¦†ç›–ï¼Œç‰¹åˆ«æ˜¯é’ˆå¯¹ C++ åç«¯çš„æ ¸å¿ƒä¸šåŠ¡é€»è¾‘éƒ¨åˆ†ã€‚é¦–å…ˆè®©æˆ‘äº†è§£ä¸€ä¸‹é¡¹ç›®çš„å½“å‰ç»“æ„ã€‚

---

<details>
            <summary>Listed current directory â€¢ **16** results</summary>
        
| Name |
|-------|
| ğŸ“ `.git` |
| ğŸ“ `build` |
| ğŸ“„ `README.md` |
| ğŸ“„ `.gitattributes` |
| ğŸ“„ `qml.qrc` |
| ğŸ“„ `CMakeLists.txt` |
| ğŸ“ `qml` |
| ğŸ“ `docs` |
| ğŸ“„ `.gitignore` |
| ğŸ“ `src` |
| ğŸ“ `resources` |
| ğŸ“ `translations` |
| ğŸ“ `.cursor` |
| ğŸ“„ `.cursorindexingignore` |
| ğŸ“ `.specstory` |
| ğŸ“„ `LICENSE` |

</details>

---

<details>
            <summary>Listed directory src â€¢ **3** results</summary>
        
| Name |
|-------|
| ğŸ“„ `main.cpp` |
| ğŸ“ `core` |
| ğŸ“ `log` |

</details>

---

<details>
            <summary>Listed directory src/core â€¢ **8** results</summary>
        
| Name |
|-------|
| ğŸ“„ `scanmanager.cpp` |
| ğŸ“„ `scanmanager.h` |
| ğŸ“„ `translator.h` |
| ğŸ“„ `translator.cpp` |
| ğŸ“„ `configmanager.cpp` |
| ğŸ“„ `configmanager.h` |
| ğŸ“„ `cleanmanager.cpp` |
| ğŸ“„ `cleanmanager.h` |

</details>

---

<details>
            <summary>Listed directory src/log â€¢ **2** results</summary>
        
| Name |
|-------|
| ğŸ“„ `logger.cpp` |
| ğŸ“„ `logger.h` |

</details>

---

ç°åœ¨è®©æˆ‘æŸ¥çœ‹æ ¸å¿ƒæ¨¡å—çš„å…·ä½“å®ç°ï¼Œä»¥ä¾¿è®¾è®¡åˆé€‚çš„å•å…ƒæµ‹è¯•ï¼š

---

Read file: src/core/scanmanager.h

---

Read file: src/core/scanmanager.cpp

---

Read file: src/core/scanmanager.cpp

---

ç°åœ¨è®©æˆ‘æŸ¥çœ‹å…¶ä»–æ ¸å¿ƒæ¨¡å—ï¼š

---

Read file: src/core/cleanmanager.h

---

Read file: src/core/configmanager.h

---

Read file: src/log/logger.h

---

ç°åœ¨è®©æˆ‘æŸ¥çœ‹ CMakeLists.txt æ¥äº†è§£é¡¹ç›®çš„æ„å»ºé…ç½®ï¼š

---

Read file: CMakeLists.txt

---

ç°åœ¨æˆ‘æ¥ä¸ºé¡¹ç›®åˆ›å»ºå®Œæ•´çš„å•å…ƒæµ‹è¯•æ¡†æ¶ã€‚æ ¹æ®è®¾è®¡æ–‡æ¡£å’Œä»£ç åˆ†æï¼Œæˆ‘å°†ä¸ºä»¥ä¸‹æ ¸å¿ƒæ¨¡å—åˆ›å»ºå•å…ƒæµ‹è¯•ï¼š

1. ScanManager - æ‰«æç®¡ç†å™¨
2. CleanManager - æ¸…ç†ç®¡ç†å™¨  
3. ConfigManager - é…ç½®ç®¡ç†å™¨
4. Logger - æ—¥å¿—æ¨¡å—

---

```diff
- 
+ cmake_minimum_required(VERSION 3.14)
+ 
+ # æŸ¥æ‰¾ Qt Test æ¨¡å—
+ find_package(Qt6 COMPONENTS Test Core Gui Qml REQUIRED)
+ 
+ # å¯ç”¨æµ‹è¯•
+ enable_testing()
+ 
+ # åŒ…å«æºä»£ç ç›®å½•
+ include_directories(../src ../src/core ../src/log)
+ 
+ # æºæ–‡ä»¶åˆ—è¡¨ï¼ˆæ’é™¤ main.cppï¼‰
+ set(CORE_SOURCES
+     ../src/core/scanmanager.cpp
+     ../src/core/cleanmanager.cpp
+     ../src/core/configmanager.cpp
+     ../src/core/translator.cpp
+     ../src/log/logger.cpp
+ )
+ 
+ set(CORE_HEADERS
+     ../src/core/scanmanager.h
+     ../src/core/cleanmanager.h
+     ../src/core/configmanager.h
+     ../src/core/translator.h
+     ../src/log/logger.h
+ )
+ 
+ # åˆ›å»ºæµ‹è¯•è¾…åŠ©åº“
+ add_library(CleanMyDeepinCore STATIC
+     ${CORE_SOURCES}
+     ${CORE_HEADERS}
+ )
+ 
+ target_link_libraries(CleanMyDeepinCore
+     Qt6::Core
+     Qt6::Gui
+     Qt6::Qml
+ )
+ 
+ # æµ‹è¯•å®å‡½æ•°
+ function(add_unit_test test_name test_source)
+     add_executable(${test_name} ${test_source})
+     target_link_libraries(${test_name}
+         Qt6::Test
+         Qt6::Core
+         Qt6::Gui
+         Qt6::Qml
+         CleanMyDeepinCore
+     )
+     add_test(NAME ${test_name} COMMAND ${test_name})
+     set_target_properties(${test_name} PROPERTIES
+         AUTOMOC ON
+     )
+ endfunction()
+ 
+ # æ·»åŠ å„ä¸ªæµ‹è¯•
+ add_unit_test(test_scanmanager test_scanmanager.cpp)
+ add_unit_test(test_cleanmanager test_cleanmanager.cpp)
+ add_unit_test(test_configmanager test_configmanager.cpp)
+ add_unit_test(test_logger test_logger.cpp)
+ 
+ # é›†æˆæµ‹è¯•
+ add_unit_test(test_integration test_integration.cpp)
+ 
+ # æµ‹è¯•æ•°æ®ç›®å½•
+ file(COPY testdata DESTINATION ${CMAKE_CURRENT_BINARY_DIR}) 
```

---

```diff
- 
+ #include <QtTest/QtTest>
+ #include <QObject>
+ #include <QSignalSpy>
+ #include <QDir>
+ #include <QTemporaryDir>
+ #include <QFile>
+ #include <QTextStream>
+ #include "scanmanager.h"
+ 
+ class TestScanManager : public QObject
+ {
+     Q_OBJECT
+ 
+ private slots:
+     void initTestCase();
+     void cleanupTestCase();
+     void init();
+     void cleanup();
+ 
+     // åŸºç¡€åŠŸèƒ½æµ‹è¯•
+     void testInitialState();
+     void testScanPaths();
+     void testItemToVariantMap();
+     void testGetChildrenEmptyDir();
+     void testGetChildrenNonExistentPath();
+     void testGetChildrenWithFiles();
+     
+     // æ‰«æåŠŸèƒ½æµ‹è¯•
+     void testStartScanSignals();
+     void testStopScan();
+     void testScanProgress();
+     void testScanDirectory();
+     
+     // æ•°æ®ç»“æ„æµ‹è¯•
+     void testScanItemStructure();
+     void testTreeResultFormat();
+     
+     // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
+     void testScanNonExistentDirectory();
+     void testScanPermissionDenied();
+     void testLargeDirectoryStructure();
+ 
+ private:
+     ScanManager *m_scanManager;
+     QTemporaryDir *m_testDir;
+     QString m_testPath;
+     
+     void createTestFileStructure();
+     void createLargeTestStructure();
+ };
+ 
+ void TestScanManager::initTestCase()
+ {
+     // åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•
+     m_testDir = new QTemporaryDir();
+     QVERIFY(m_testDir->isValid());
+     m_testPath = m_testDir->path();
+     
+     qDebug() << "Test directory created at:" << m_testPath;
+ }
+ 
+ void TestScanManager::cleanupTestCase()
+ {
+     delete m_testDir;
+ }
+ 
+ void TestScanManager::init()
+ {
+     m_scanManager = new ScanManager(this);
+     createTestFileStructure();
+ }
+ 
+ void TestScanManager::cleanup()
+ {
+     delete m_scanManager;
+     m_scanManager = nullptr;
+     
+     // æ¸…ç†æµ‹è¯•ç›®å½•å†…å®¹
+     QDir dir(m_testPath);
+     dir.removeRecursively();
+     m_testDir->remove();
+     m_testDir = new QTemporaryDir();
+     m_testPath = m_testDir->path();
+ }
+ 
+ void TestScanManager::createTestFileStructure()
+ {
+     // åˆ›å»ºæµ‹è¯•æ–‡ä»¶ç»“æ„
+     // testdir/
+     //   â”œâ”€â”€ file1.txt (100 bytes)
+     //   â”œâ”€â”€ file2.log (200 bytes)
+     //   â”œâ”€â”€ subdir1/
+     //   â”‚   â”œâ”€â”€ file3.tmp (300 bytes)
+     //   â”‚   â””â”€â”€ subdir2/
+     //   â”‚       â””â”€â”€ file4.cache (400 bytes)
+     //   â””â”€â”€ emptydir/
+     
+     QDir testDir(m_testPath);
+     
+     // åˆ›å»ºæ–‡ä»¶
+     QFile file1(testDir.filePath("file1.txt"));
+     QVERIFY(file1.open(QIODevice::WriteOnly));
+     file1.write(QByteArray(100, 'a'));
+     file1.close();
+     
+     QFile file2(testDir.filePath("file2.log"));
+     QVERIFY(file2.open(QIODevice::WriteOnly));
+     file2.write(QByteArray(200, 'b'));
+     file2.close();
+     
+     // åˆ›å»ºå­ç›®å½•
+     QVERIFY(testDir.mkdir("subdir1"));
+     QVERIFY(testDir.mkdir("subdir1/subdir2"));
+     QVERIFY(testDir.mkdir("emptydir"));
+     
+     QFile file3(testDir.filePath("subdir1/file3.tmp"));
+     QVERIFY(file3.open(QIODevice::WriteOnly));
+     file3.write(QByteArray(300, 'c'));
+     file3.close();
+     
+     QFile file4(testDir.filePath("subdir1/subdir2/file4.cache"));
+     QVERIFY(file4.open(QIODevice::WriteOnly));
+     file4.write(QByteArray(400, 'd'));
+     file4.close();
+ }
+ 
+ void TestScanManager::testInitialState()
+ {
+     // æµ‹è¯•åˆå§‹çŠ¶æ€
+     QCOMPARE(m_scanManager->progress(), 0.0);
+     QCOMPARE(m_scanManager->scannedFiles(), 0);
+     QCOMPARE(m_scanManager->scannedDirs(), 0);
+     QVERIFY(m_scanManager->treeResult().toList().isEmpty());
+ }
+ 
+ void TestScanManager::testScanPaths()
+ {
+     // æµ‹è¯•æ‰«æè·¯å¾„å¸¸é‡
+     const QStringList &paths = ScanManager::kScanPaths;
+     QVERIFY(!paths.isEmpty());
+     
+     // éªŒè¯åŒ…å«åŸºæœ¬çš„ç³»ç»Ÿè·¯å¾„
+     QVERIFY(paths.contains("/tmp"));
+     QVERIFY(paths.contains("/var/tmp"));
+     QVERIFY(paths.contains("/var/log"));
+     
+     // éªŒè¯ç”¨æˆ·ç›®å½•è·¯å¾„æ ¼å¼æ­£ç¡®
+     bool hasUserPath = false;
+     for (const QString &path : paths) {
+         if (path.contains("/.thumbnails")) {
+             hasUserPath = true;
+             break;
+         }
+     }
+     QVERIFY(hasUserPath);
+ }
+ 
+ void TestScanManager::testItemToVariantMap()
+ {
+     // åˆ›å»ºæµ‹è¯• ScanItem
+     ScanManager::ScanItem item;
+     item.name = "test.txt";
+     item.path = "/tmp/test.txt";
+     item.isDir = false;
+     item.size = 1024;
+     
+     // ä½¿ç”¨åå°„è°ƒç”¨ç§æœ‰æ–¹æ³•è¿›è¡Œæµ‹è¯•
+     // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å°† itemToVariantMap æ–¹æ³•è®¾ä¸º public æˆ–æ·»åŠ å‹å…ƒç±»
+     // æˆ–è€…é€šè¿‡æµ‹è¯• getChildren æ–¹æ³•é—´æ¥æµ‹è¯•
+     
+     // é€šè¿‡ getChildren æµ‹è¯•æ•°æ®è½¬æ¢
+     QVariant result = m_scanManager->getChildren(m_testPath);
+     QVariantList children = result.toList();
+     
+     QVERIFY(!children.isEmpty());
+     
+     // éªŒè¯ç¬¬ä¸€ä¸ªå­é¡¹çš„æ•°æ®ç»“æ„
+     QVariantMap firstChild = children.first().toMap();
+     QVERIFY(firstChild.contains("name"));
+     QVERIFY(firstChild.contains("path"));
+     QVERIFY(firstChild.contains("isDir"));
+     QVERIFY(firstChild.contains("size"));
+     QVERIFY(firstChild.contains("expanded"));
+     QVERIFY(firstChild.contains("hasChildren"));
+     QVERIFY(firstChild.contains("childrenLoaded"));
+     QVERIFY(firstChild.contains("children"));
+     
+     // éªŒè¯é»˜è®¤çŠ¶æ€
+     QCOMPARE(firstChild["expanded"].toBool(), false);
+     QCOMPARE(firstChild["childrenLoaded"].toBool(), false);
+     QVERIFY(firstChild["children"].toList().isEmpty());
+ }
+ 
+ void TestScanManager::testGetChildrenEmptyDir()
+ {
+     // æµ‹è¯•ç©ºç›®å½•
+     QString emptyDirPath = QDir(m_testPath).filePath("emptydir");
+     QVariant result = m_scanManager->getChildren(emptyDirPath);
+     QVariantList children = result.toList();
+     
+     QVERIFY(children.isEmpty());
+ }
+ 
+ void TestScanManager::testGetChildrenNonExistentPath()
+ {
+     // æµ‹è¯•ä¸å­˜åœ¨çš„è·¯å¾„
+     QString nonExistentPath = "/path/that/does/not/exist";
+     QVariant result = m_scanManager->getChildren(nonExistentPath);
+     QVariantList children = result.toList();
+     
+     QVERIFY(children.isEmpty());
+ }
+ 
+ void TestScanManager::testGetChildrenWithFiles()
+ {
+     // æµ‹è¯•åŒ…å«æ–‡ä»¶çš„ç›®å½•
+     QVariant result = m_scanManager->getChildren(m_testPath);
+     QVariantList children = result.toList();
+     
+     QVERIFY(children.size() >= 3); // file1.txt, file2.log, subdir1, emptydir
+     
+     // æŸ¥æ‰¾å¹¶éªŒè¯æ–‡ä»¶é¡¹
+     bool foundFile1 = false, foundSubdir1 = false;
+     for (const QVariant &child : children) {
+         QVariantMap childMap = child.toMap();
+         QString name = childMap["name"].toString();
+         
+         if (name == "file1.txt") {
+             foundFile1 = true;
+             QCOMPARE(childMap["isDir"].toBool(), false);
+             QCOMPARE(childMap["size"].toLongLong(), 100LL);
+             QCOMPARE(childMap["hasChildren"].toBool(), false);
+         } else if (name == "subdir1") {
+             foundSubdir1 = true;
+             QCOMPARE(childMap["isDir"].toBool(), true);
+             QCOMPARE(childMap["hasChildren"].toBool(), true);
+         }
+     }
+     
+     QVERIFY(foundFile1);
+     QVERIFY(foundSubdir1);
+ }
+ 
+ void TestScanManager::testStartScanSignals()
+ {
+     // æµ‹è¯•æ‰«æå¼€å§‹æ—¶çš„ä¿¡å·å‘å°„
+     QSignalSpy progressSpy(m_scanManager, &ScanManager::progressChanged);
+     QSignalSpy filesSpy(m_scanManager, &ScanManager::scannedFilesChanged);
+     QSignalSpy dirsSpy(m_scanManager, &ScanManager::scannedDirsChanged);
+     QSignalSpy treeSpy(m_scanManager, &ScanManager::treeResultChanged);
+     QSignalSpy finishedSpy(m_scanManager, &ScanManager::scanFinished);
+     
+     m_scanManager->startScan();
+     
+     // éªŒè¯åˆå§‹ä¿¡å·
+     QVERIFY(progressSpy.count() >= 1);
+     QVERIFY(filesSpy.count() >= 1);
+     QVERIFY(dirsSpy.count() >= 1);
+     QVERIFY(treeSpy.count() >= 1);
+     
+     // ç­‰å¾…æ‰«æå®Œæˆ
+     QVERIFY(finishedSpy.wait(5000)); // 5ç§’è¶…æ—¶
+     
+     // éªŒè¯æœ€ç»ˆçŠ¶æ€
+     QCOMPARE(m_scanManager->progress(), 1.0);
+ }
+ 
+ void TestScanManager::testStopScan()
+ {
+     // æµ‹è¯•åœæ­¢æ‰«æ
+     m_scanManager->startScan();
+     
+     // ç«‹å³åœæ­¢
+     m_scanManager->stopScan();
+     
+     // éªŒè¯æ‰«æå·²åœæ­¢ï¼ˆé€šè¿‡æ£€æŸ¥è¿›åº¦æ˜¯å¦ä¸å†æ›´æ–°ï¼‰
+     qreal initialProgress = m_scanManager->progress();
+     QTest::qWait(100);
+     
+     // è¿›åº¦åº”è¯¥ä¿æŒä¸å˜æˆ–è€…æ‰«æåº”è¯¥å¾ˆå¿«å®Œæˆ
+     QVERIFY(m_scanManager->progress() >= initialProgress);
+ }
+ 
+ void TestScanManager::testScanProgress()
+ {
+     // æµ‹è¯•æ‰«æè¿›åº¦ä¿¡å·
+     QSignalSpy progressSignalSpy(m_scanManager, &ScanManager::scanProgress);
+     QSignalSpy finishedSpy(m_scanManager, &ScanManager::scanFinished);
+     
+     m_scanManager->startScan();
+     
+     // ç­‰å¾…æ‰«æå®Œæˆ
+     QVERIFY(finishedSpy.wait(5000));
+     
+     // éªŒè¯è¿›åº¦ä¿¡å·
+     QVERIFY(progressSignalSpy.count() >= 1);
+     
+     // éªŒè¯æœ€åä¸€ä¸ªè¿›åº¦ä¿¡å·æ˜¯100%
+     if (!progressSignalSpy.isEmpty()) {
+         QList<QVariant> lastSignal = progressSignalSpy.last();
+         QCOMPARE(lastSignal.at(0).toInt(), 100);
+     }
+ }
+ 
+ void TestScanManager::testScanDirectory()
+ {
+     // è¿™ä¸ªæµ‹è¯•éœ€è¦è®¿é—®ç§æœ‰æ–¹æ³•ï¼Œå¯ä»¥é€šè¿‡å‹å…ƒç±»æˆ–è€…é‡æ„ä¸º protected æ–¹æ³•
+     // ç›®å‰é€šè¿‡ startScan é—´æ¥æµ‹è¯•
+     
+     QSignalSpy finishedSpy(m_scanManager, &ScanManager::scanFinished);
+     m_scanManager->startScan();
+     
+     QVERIFY(finishedSpy.wait(5000));
+     
+     // éªŒè¯æ‰«æç»“æœåŒ…å«é¢„æœŸçš„æ–‡ä»¶å’Œç›®å½•æ•°é‡
+     QVERIFY(m_scanManager->scannedFiles() > 0);
+     QVERIFY(m_scanManager->scannedDirs() > 0);
+ }
+ 
+ void TestScanManager::testScanItemStructure()
+ {
+     // æµ‹è¯• ScanItem ç»“æ„ä½“çš„åŸºæœ¬åŠŸèƒ½
+     ScanManager::ScanItem item;
+     item.name = "test";
+     item.path = "/test";
+     item.isDir = true;
+     item.size = 0;
+     
+     // æ·»åŠ å­é¡¹
+     ScanManager::ScanItem child;
+     child.name = "child.txt";
+     child.path = "/test/child.txt";
+     child.isDir = false;
+     child.size = 100;
+     
+     item.children.append(child);
+     
+     // éªŒè¯ç»“æ„
+     QCOMPARE(item.children.size(), 1);
+     QCOMPARE(item.children.first().name, QString("child.txt"));
+     QCOMPARE(item.children.first().size, 100LL);
+ }
+ 
+ void TestScanManager::testTreeResultFormat()
+ {
+     // æµ‹è¯•æ ‘å½¢ç»“æœçš„æ ¼å¼
+     QSignalSpy finishedSpy(m_scanManager, &ScanManager::scanFinished);
+     m_scanManager->startScan();
+     
+     QVERIFY(finishedSpy.wait(5000));
+     
+     QVariant treeResult = m_scanManager->treeResult();
+     QVERIFY(treeResult.isValid());
+     
+     QVariantList rootNodes = treeResult.toList();
+     // æ ¹æ® kScanPaths çš„æ•°é‡éªŒè¯æ ¹èŠ‚ç‚¹æ•°é‡
+     QVERIFY(rootNodes.size() > 0);
+     
+     // éªŒè¯æ ¹èŠ‚ç‚¹çš„æ•°æ®ç»“æ„
+     if (!rootNodes.isEmpty()) {
+         QVariantMap firstRoot = rootNodes.first().toMap();
+         QVERIFY(firstRoot.contains("name"));
+         QVERIFY(firstRoot.contains("path"));
+         QVERIFY(firstRoot.contains("isDir"));
+         QVERIFY(firstRoot.contains("size"));
+         QVERIFY(firstRoot.contains("children"));
+     }
+ }
+ 
+ void TestScanManager::testScanNonExistentDirectory()
+ {
+     // æµ‹è¯•æ‰«æä¸å­˜åœ¨çš„ç›®å½•
+     QString nonExistentPath = "/path/that/absolutely/does/not/exist";
+     QVariant result = m_scanManager->getChildren(nonExistentPath);
+     
+     QVERIFY(result.toList().isEmpty());
+ }
+ 
+ void TestScanManager::testScanPermissionDenied()
+ {
+     // æµ‹è¯•æƒé™è¢«æ‹’ç»çš„ç›®å½•
+     // æ³¨æ„ï¼šè¿™ä¸ªæµ‹è¯•å¯èƒ½éœ€è¦ç‰¹æ®Šçš„æƒé™è®¾ç½®ï¼Œåœ¨æŸäº›ç¯å¢ƒä¸‹å¯èƒ½è·³è¿‡
+     QString restrictedPath = "/root"; // é€šå¸¸æ™®é€šç”¨æˆ·æ— æ³•è®¿é—®
+     
+     QVariant result = m_scanManager->getChildren(restrictedPath);
+     // æƒé™è¢«æ‹’ç»æ—¶åº”è¯¥è¿”å›ç©ºåˆ—è¡¨è€Œä¸æ˜¯å´©æºƒ
+     QVERIFY(result.toList().isEmpty() || !result.toList().isEmpty());
+ }
+ 
+ void TestScanManager::testLargeDirectoryStructure()
+ {
+     // åˆ›å»ºå¤§å‹ç›®å½•ç»“æ„è¿›è¡Œæ€§èƒ½æµ‹è¯•
+     createLargeTestStructure();
+     
+     QSignalSpy finishedSpy(m_scanManager, &ScanManager::scanFinished);
+     
+     // è®°å½•å¼€å§‹æ—¶é—´
+     QElapsedTimer timer;
+     timer.start();
+     
+     m_scanManager->startScan();
+     QVERIFY(finishedSpy.wait(10000)); // 10ç§’è¶…æ—¶
+     
+     qint64 elapsed = timer.elapsed();
+     qDebug() << "Large directory scan took:" << elapsed << "ms";
+     
+     // éªŒè¯æ‰«æå®Œæˆ
+     QCOMPARE(m_scanManager->progress(), 1.0);
+     QVERIFY(m_scanManager->scannedFiles() > 0);
+ }
+ 
+ void TestScanManager::createLargeTestStructure()
+ {
+     // åˆ›å»ºåŒ…å«å¤šå±‚åµŒå¥—å’Œå¤šä¸ªæ–‡ä»¶çš„å¤§å‹æµ‹è¯•ç»“æ„
+     QDir testDir(m_testPath);
+     
+     // åˆ›å»ºå¤šå±‚ç›®å½•ç»“æ„
+     for (int i = 0; i < 5; ++i) {
+         QString dirName = QString("level%1").arg(i);
+         testDir.mkdir(dirName);
+         
+         QDir subDir(testDir.filePath(dirName));
+         
+         // åœ¨æ¯ä¸ªç›®å½•ä¸­åˆ›å»ºå¤šä¸ªæ–‡ä»¶
+         for (int j = 0; j < 10; ++j) {
+             QString fileName = QString("file%1_%2.txt").arg(i).arg(j);
+             QFile file(subDir.filePath(fileName));
+             if (file.open(QIODevice::WriteOnly)) {
+                 file.write(QByteArray(100 * (i + 1), 'x'));
+                 file.close();
+             }
+         }
+         
+         // åˆ›å»ºå­ç›®å½•
+         if (i < 3) {
+             subDir.mkdir(QString("sublevel%1").arg(i));
+         }
+     }
+ }
+ 
+ QTEST_MAIN(TestScanManager)
+ #include "test_scanmanager.moc" 
```

---

```diff
- 
+ #include <QtTest/QtTest>
+ #include <QObject>
+ #include <QSignalSpy>
+ #include <QDir>
+ #include <QTemporaryDir>
+ #include <QFile>
+ #include <QVariantList>
+ #include <QVariantMap>
+ #include "cleanmanager.h"
+ 
+ class TestCleanManager : public QObject
+ {
+     Q_OBJECT
+ 
+ private slots:
+     void initTestCase();
+     void cleanupTestCase();
+     void init();
+     void cleanup();
+ 
+     // åŸºç¡€åŠŸèƒ½æµ‹è¯•
+     void testInitialState();
+     void testStartCleanEmptyList();
+     void testStartCleanSingleFile();
+     void testStartCleanMultipleFiles();
+     void testStartCleanDirectory();
+     
+     // ä¿¡å·æµ‹è¯•
+     void testCleanProgressSignal();
+     void testCleanFinishedSignal();
+     
+     // é”™è¯¯å¤„ç†æµ‹è¯•
+     void testCleanNonExistentFile();
+     void testCleanPermissionDenied();
+     void testCleanInvalidInput();
+     
+     // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
+     void testCleanLargeFile();
+     void testCleanManyFiles();
+     void testCleanNestedDirectories();
+ 
+ private:
+     CleanManager *m_cleanManager;
+     QTemporaryDir *m_testDir;
+     QString m_testPath;
+     
+     void createTestFiles();
+     QVariantList createFileList(const QStringList &paths);
+     void createLargeTestFile(const QString &path, qint64 size);
+ };
+ 
+ void TestCleanManager::initTestCase()
+ {
+     // åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•
+     m_testDir = new QTemporaryDir();
+     QVERIFY(m_testDir->isValid());
+     m_testPath = m_testDir->path();
+     
+     qDebug() << "Test directory created at:" << m_testPath;
+ }
+ 
+ void TestCleanManager::cleanupTestCase()
+ {
+     delete m_testDir;
+ }
+ 
+ void TestCleanManager::init()
+ {
+     m_cleanManager = new CleanManager(this);
+     createTestFiles();
+ }
+ 
+ void TestCleanManager::cleanup()
+ {
+     delete m_cleanManager;
+     m_cleanManager = nullptr;
+     
+     // æ¸…ç†æµ‹è¯•ç›®å½•å†…å®¹
+     QDir dir(m_testPath);
+     dir.removeRecursively();
+     m_testDir->remove();
+     m_testDir = new QTemporaryDir();
+     m_testPath = m_testDir->path();
+ }
+ 
+ void TestCleanManager::createTestFiles()
+ {
+     // åˆ›å»ºæµ‹è¯•æ–‡ä»¶ç»“æ„
+     QDir testDir(m_testPath);
+     
+     // åˆ›å»ºæ™®é€šæ–‡ä»¶
+     QFile file1(testDir.filePath("test1.txt"));
+     QVERIFY(file1.open(QIODevice::WriteOnly));
+     file1.write("Test content 1");
+     file1.close();
+     
+     QFile file2(testDir.filePath("test2.log"));
+     QVERIFY(file2.open(QIODevice::WriteOnly));
+     file2.write("Test content 2");
+     file2.close();
+     
+     // åˆ›å»ºå­ç›®å½•å’Œæ–‡ä»¶
+     QVERIFY(testDir.mkdir("subdir"));
+     QFile file3(testDir.filePath("subdir/test3.tmp"));
+     QVERIFY(file3.open(QIODevice::WriteOnly));
+     file3.write("Test content 3");
+     file3.close();
+     
+     // åˆ›å»ºç©ºç›®å½•
+     QVERIFY(testDir.mkdir("emptydir"));
+ }
+ 
+ QVariantList TestCleanManager::createFileList(const QStringList &paths)
+ {
+     QVariantList fileList;
+     for (const QString &path : paths) {
+         QVariantMap fileItem;
+         fileItem["path"] = path;
+         fileItem["isDir"] = QFileInfo(path).isDir();
+         fileItem["size"] = QFileInfo(path).size();
+         fileList.append(fileItem);
+     }
+     return fileList;
+ }
+ 
+ void TestCleanManager::createLargeTestFile(const QString &path, qint64 size)
+ {
+     QFile file(path);
+     if (file.open(QIODevice::WriteOnly)) {
+         // åˆ›å»ºæŒ‡å®šå¤§å°çš„æ–‡ä»¶
+         QByteArray data(1024, 'X'); // 1KB å—
+         qint64 written = 0;
+         while (written < size) {
+             qint64 toWrite = qMin(static_cast<qint64>(data.size()), size - written);
+             file.write(data.left(toWrite));
+             written += toWrite;
+         }
+         file.close();
+     }
+ }
+ 
+ void TestCleanManager::testInitialState()
+ {
+     // æµ‹è¯•åˆå§‹çŠ¶æ€
+     // CleanManager æ²¡æœ‰å…¬å¼€çš„çŠ¶æ€å±æ€§ï¼Œä¸»è¦é€šè¿‡ä¿¡å·æµ‹è¯•
+     QVERIFY(m_cleanManager != nullptr);
+ }
+ 
+ void TestCleanManager::testStartCleanEmptyList()
+ {
+     // æµ‹è¯•æ¸…ç†ç©ºåˆ—è¡¨
+     QSignalSpy progressSpy(m_cleanManager, &CleanManager::cleanProgress);
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList emptyList;
+     m_cleanManager->startClean(emptyList);
+     
+     // ç­‰å¾…å®Œæˆä¿¡å·
+     QVERIFY(finishedSpy.wait(1000));
+     
+     // éªŒè¯ç»“æœ
+     QCOMPARE(finishedSpy.count(), 1);
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QCOMPARE(finishedArgs.at(0).toInt(), 0); // é‡Šæ”¾ç©ºé—´ä¸º0
+     QVERIFY(finishedArgs.at(1).toList().isEmpty()); // æ²¡æœ‰å¤±è´¥é¡¹
+ }
+ 
+ void TestCleanManager::testStartCleanSingleFile()
+ {
+     // æµ‹è¯•æ¸…ç†å•ä¸ªæ–‡ä»¶
+     QString filePath = QDir(m_testPath).filePath("test1.txt");
+     QVERIFY(QFile::exists(filePath));
+     
+     qint64 originalSize = QFileInfo(filePath).size();
+     
+     QSignalSpy progressSpy(m_cleanManager, &CleanManager::cleanProgress);
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList({filePath});
+     m_cleanManager->startClean(fileList);
+     
+     // ç­‰å¾…å®Œæˆä¿¡å·
+     QVERIFY(finishedSpy.wait(2000));
+     
+     // éªŒè¯æ–‡ä»¶å·²è¢«åˆ é™¤
+     QVERIFY(!QFile::exists(filePath));
+     
+     // éªŒè¯ä¿¡å·
+     QCOMPARE(finishedSpy.count(), 1);
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QVERIFY(finishedArgs.at(0).toInt() >= originalSize); // é‡Šæ”¾çš„ç©ºé—´åº”è¯¥è‡³å°‘ç­‰äºæ–‡ä»¶å¤§å°
+     QVERIFY(finishedArgs.at(1).toList().isEmpty()); // æ²¡æœ‰å¤±è´¥é¡¹
+ }
+ 
+ void TestCleanManager::testStartCleanMultipleFiles()
+ {
+     // æµ‹è¯•æ¸…ç†å¤šä¸ªæ–‡ä»¶
+     QStringList filePaths = {
+         QDir(m_testPath).filePath("test1.txt"),
+         QDir(m_testPath).filePath("test2.log"),
+         QDir(m_testPath).filePath("subdir/test3.tmp")
+     };
+     
+     // éªŒè¯æ–‡ä»¶å­˜åœ¨
+     for (const QString &path : filePaths) {
+         QVERIFY(QFile::exists(path));
+     }
+     
+     qint64 totalSize = 0;
+     for (const QString &path : filePaths) {
+         totalSize += QFileInfo(path).size();
+     }
+     
+     QSignalSpy progressSpy(m_cleanManager, &CleanManager::cleanProgress);
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList(filePaths);
+     m_cleanManager->startClean(fileList);
+     
+     // ç­‰å¾…å®Œæˆä¿¡å·
+     QVERIFY(finishedSpy.wait(3000));
+     
+     // éªŒè¯æ–‡ä»¶å·²è¢«åˆ é™¤
+     for (const QString &path : filePaths) {
+         QVERIFY(!QFile::exists(path));
+     }
+     
+     // éªŒè¯è¿›åº¦ä¿¡å·
+     QVERIFY(progressSpy.count() >= 1);
+     
+     // éªŒè¯å®Œæˆä¿¡å·
+     QCOMPARE(finishedSpy.count(), 1);
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QVERIFY(finishedArgs.at(0).toInt() >= totalSize);
+     QVERIFY(finishedArgs.at(1).toList().isEmpty());
+ }
+ 
+ void TestCleanManager::testStartCleanDirectory()
+ {
+     // æµ‹è¯•æ¸…ç†ç›®å½•
+     QString dirPath = QDir(m_testPath).filePath("subdir");
+     QVERIFY(QDir(dirPath).exists());
+     
+     QSignalSpy progressSpy(m_cleanManager, &CleanManager::cleanProgress);
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList dirList = createFileList({dirPath});
+     m_cleanManager->startClean(dirList);
+     
+     // ç­‰å¾…å®Œæˆä¿¡å·
+     QVERIFY(finishedSpy.wait(3000));
+     
+     // éªŒè¯ç›®å½•å·²è¢«åˆ é™¤
+     QVERIFY(!QDir(dirPath).exists());
+     
+     // éªŒè¯ä¿¡å·
+     QCOMPARE(finishedSpy.count(), 1);
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QVERIFY(finishedArgs.at(0).toInt() >= 0); // é‡Šæ”¾äº†ä¸€äº›ç©ºé—´
+ }
+ 
+ void TestCleanManager::testCleanProgressSignal()
+ {
+     // æµ‹è¯•è¿›åº¦ä¿¡å·çš„æ­£ç¡®æ€§
+     QStringList filePaths = {
+         QDir(m_testPath).filePath("test1.txt"),
+         QDir(m_testPath).filePath("test2.log")
+     };
+     
+     QSignalSpy progressSpy(m_cleanManager, &CleanManager::cleanProgress);
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList(filePaths);
+     m_cleanManager->startClean(fileList);
+     
+     QVERIFY(finishedSpy.wait(3000));
+     
+     // éªŒè¯è¿›åº¦ä¿¡å·
+     QVERIFY(progressSpy.count() >= 1);
+     
+     // æ£€æŸ¥è¿›åº¦ä¿¡å·çš„å‚æ•°
+     for (int i = 0; i < progressSpy.count(); ++i) {
+         QList<QVariant> progressArgs = progressSpy.at(i);
+         QCOMPARE(progressArgs.size(), 2);
+         
+         int percent = progressArgs.at(0).toInt();
+         QString currentFile = progressArgs.at(1).toString();
+         
+         // è¿›åº¦åº”è¯¥åœ¨ 0-100 ä¹‹é—´
+         QVERIFY(percent >= 0 && percent <= 100);
+         // å½“å‰æ–‡ä»¶è·¯å¾„ä¸åº”è¯¥ä¸ºç©º
+         QVERIFY(!currentFile.isEmpty());
+     }
+ }
+ 
+ void TestCleanManager::testCleanFinishedSignal()
+ {
+     // æµ‹è¯•å®Œæˆä¿¡å·çš„æ­£ç¡®æ€§
+     QString filePath = QDir(m_testPath).filePath("test1.txt");
+     qint64 fileSize = QFileInfo(filePath).size();
+     
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList({filePath});
+     m_cleanManager->startClean(fileList);
+     
+     QVERIFY(finishedSpy.wait(2000));
+     
+     // éªŒè¯å®Œæˆä¿¡å·å‚æ•°
+     QCOMPARE(finishedSpy.count(), 1);
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QCOMPARE(finishedArgs.size(), 2);
+     
+     int freedSpace = finishedArgs.at(0).toInt();
+     QVariantList failedItems = finishedArgs.at(1).toList();
+     
+     // é‡Šæ”¾ç©ºé—´åº”è¯¥å¤§äºç­‰äºæ–‡ä»¶å¤§å°
+     QVERIFY(freedSpace >= fileSize);
+     // æ²¡æœ‰å¤±è´¥é¡¹
+     QVERIFY(failedItems.isEmpty());
+ }
+ 
+ void TestCleanManager::testCleanNonExistentFile()
+ {
+     // æµ‹è¯•æ¸…ç†ä¸å­˜åœ¨çš„æ–‡ä»¶
+     QString nonExistentPath = QDir(m_testPath).filePath("nonexistent.txt");
+     QVERIFY(!QFile::exists(nonExistentPath));
+     
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList({nonExistentPath});
+     m_cleanManager->startClean(fileList);
+     
+     QVERIFY(finishedSpy.wait(2000));
+     
+     // éªŒè¯ç»“æœ
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     int freedSpace = finishedArgs.at(0).toInt();
+     QVariantList failedItems = finishedArgs.at(1).toList();
+     
+     // é‡Šæ”¾ç©ºé—´åº”è¯¥ä¸º0
+     QCOMPARE(freedSpace, 0);
+     // åº”è¯¥æœ‰ä¸€ä¸ªå¤±è´¥é¡¹
+     QCOMPARE(failedItems.size(), 1);
+     
+     // éªŒè¯å¤±è´¥é¡¹çš„å†…å®¹
+     QVariantMap failedItem = failedItems.first().toMap();
+     QCOMPARE(failedItem["path"].toString(), nonExistentPath);
+ }
+ 
+ void TestCleanManager::testCleanPermissionDenied()
+ {
+     // æµ‹è¯•æƒé™è¢«æ‹’ç»çš„æƒ…å†µ
+     // åˆ›å»ºä¸€ä¸ªåªè¯»æ–‡ä»¶
+     QString readOnlyPath = QDir(m_testPath).filePath("readonly.txt");
+     QFile readOnlyFile(readOnlyPath);
+     QVERIFY(readOnlyFile.open(QIODevice::WriteOnly));
+     readOnlyFile.write("readonly content");
+     readOnlyFile.close();
+     
+     // è®¾ç½®ä¸ºåªè¯»
+     QVERIFY(readOnlyFile.setPermissions(QFile::ReadOwner | QFile::ReadGroup | QFile::ReadOther));
+     
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList({readOnlyPath});
+     m_cleanManager->startClean(fileList);
+     
+     QVERIFY(finishedSpy.wait(2000));
+     
+     // éªŒè¯ç»“æœ - å¯èƒ½æˆåŠŸä¹Ÿå¯èƒ½å¤±è´¥ï¼Œå–å†³äºå…·ä½“å®ç°
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QVariantList failedItems = finishedArgs.at(1).toList();
+     
+     // å¦‚æœåˆ é™¤å¤±è´¥ï¼Œåº”è¯¥åœ¨å¤±è´¥åˆ—è¡¨ä¸­
+     if (!QFile::exists(readOnlyPath)) {
+         // åˆ é™¤æˆåŠŸ
+         QVERIFY(failedItems.isEmpty());
+     } else {
+         // åˆ é™¤å¤±è´¥
+         QCOMPARE(failedItems.size(), 1);
+     }
+ }
+ 
+ void TestCleanManager::testCleanInvalidInput()
+ {
+     // æµ‹è¯•æ— æ•ˆè¾“å…¥
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     // æµ‹è¯•æ— æ•ˆçš„ QVariant
+     QVariant invalidInput = QString("invalid");
+     m_cleanManager->startClean(invalidInput);
+     
+     QVERIFY(finishedSpy.wait(1000));
+     
+     // åº”è¯¥å¿«é€Ÿå®Œæˆï¼Œæ²¡æœ‰é‡Šæ”¾ç©ºé—´
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QCOMPARE(finishedArgs.at(0).toInt(), 0);
+ }
+ 
+ void TestCleanManager::testCleanLargeFile()
+ {
+     // æµ‹è¯•æ¸…ç†å¤§æ–‡ä»¶
+     QString largeFilePath = QDir(m_testPath).filePath("largefile.dat");
+     qint64 largeFileSize = 10 * 1024 * 1024; // 10MB
+     
+     createLargeTestFile(largeFilePath, largeFileSize);
+     QVERIFY(QFile::exists(largeFilePath));
+     QVERIFY(QFileInfo(largeFilePath).size() >= largeFileSize);
+     
+     QSignalSpy progressSpy(m_cleanManager, &CleanManager::cleanProgress);
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList({largeFilePath});
+     m_cleanManager->startClean(fileList);
+     
+     // å¤§æ–‡ä»¶å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´
+     QVERIFY(finishedSpy.wait(10000));
+     
+     // éªŒè¯æ–‡ä»¶å·²åˆ é™¤
+     QVERIFY(!QFile::exists(largeFilePath));
+     
+     // éªŒè¯é‡Šæ”¾çš„ç©ºé—´
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QVERIFY(finishedArgs.at(0).toLongLong() >= largeFileSize);
+ }
+ 
+ void TestCleanManager::testCleanManyFiles()
+ {
+     // æµ‹è¯•æ¸…ç†å¤§é‡æ–‡ä»¶
+     QStringList manyFiles;
+     QDir testDir(m_testPath);
+     
+     // åˆ›å»º100ä¸ªå°æ–‡ä»¶
+     for (int i = 0; i < 100; ++i) {
+         QString fileName = QString("manyfile_%1.txt").arg(i);
+         QString filePath = testDir.filePath(fileName);
+         
+         QFile file(filePath);
+         QVERIFY(file.open(QIODevice::WriteOnly));
+         file.write(QString("Content of file %1").arg(i).toUtf8());
+         file.close();
+         
+         manyFiles.append(filePath);
+     }
+     
+     QSignalSpy progressSpy(m_cleanManager, &CleanManager::cleanProgress);
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     QVariantList fileList = createFileList(manyFiles);
+     m_cleanManager->startClean(fileList);
+     
+     QVERIFY(finishedSpy.wait(10000));
+     
+     // éªŒè¯æ‰€æœ‰æ–‡ä»¶éƒ½è¢«åˆ é™¤
+     for (const QString &filePath : manyFiles) {
+         QVERIFY(!QFile::exists(filePath));
+     }
+     
+     // éªŒè¯è¿›åº¦ä¿¡å·æ•°é‡åˆç†
+     QVERIFY(progressSpy.count() >= 1);
+     QVERIFY(progressSpy.count() <= 100); // ä¸åº”è¯¥è¶…è¿‡æ–‡ä»¶æ•°é‡
+ }
+ 
+ void TestCleanManager::testCleanNestedDirectories()
+ {
+     // æµ‹è¯•æ¸…ç†åµŒå¥—ç›®å½•ç»“æ„
+     QDir testDir(m_testPath);
+     
+     // åˆ›å»ºåµŒå¥—ç›®å½•ç»“æ„
+     QString nestedPath = "nested/level1/level2/level3";
+     QVERIFY(testDir.mkpath(nestedPath));
+     
+     // åœ¨å„çº§ç›®å½•ä¸­åˆ›å»ºæ–‡ä»¶
+     QStringList filesToCreate = {
+         "nested/file1.txt",
+         "nested/level1/file2.txt",
+         "nested/level1/level2/file3.txt",
+         "nested/level1/level2/level3/file4.txt"
+     };
+     
+     for (const QString &relativePath : filesToCreate) {
+         QString fullPath = testDir.filePath(relativePath);
+         QFile file(fullPath);
+         QVERIFY(file.open(QIODevice::WriteOnly));
+         file.write("nested content");
+         file.close();
+     }
+     
+     QSignalSpy finishedSpy(m_cleanManager, &CleanManager::cleanFinished);
+     
+     // æ¸…ç†æ•´ä¸ªåµŒå¥—ç›®å½•
+     QString nestedDirPath = testDir.filePath("nested");
+     QVariantList dirList = createFileList({nestedDirPath});
+     m_cleanManager->startClean(dirList);
+     
+     QVERIFY(finishedSpy.wait(5000));
+     
+     // éªŒè¯æ•´ä¸ªç›®å½•ç»“æ„éƒ½è¢«åˆ é™¤
+     QVERIFY(!QDir(nestedDirPath).exists());
+     
+     // éªŒè¯é‡Šæ”¾äº†ç©ºé—´
+     QList<QVariant> finishedArgs = finishedSpy.first();
+     QVERIFY(finishedArgs.at(0).toInt() > 0);
+ }
+ 
+ QTEST_MAIN(TestCleanManager)
+ #include "test_cleanmanager.moc" 
```

---

```diff
- 
+ #include <QtTest/QtTest>
+ #include <QObject>
+ #include <QSignalSpy>
+ #include <QSettings>
+ #include <QStandardPaths>
+ #include <QDir>
+ #include "configmanager.h"
+ 
+ class TestConfigManager : public QObject
+ {
+     Q_OBJECT
+ 
+ private slots:
+     void initTestCase();
+     void cleanupTestCase();
+     void init();
+     void cleanup();
+ 
+     // åŸºç¡€åŠŸèƒ½æµ‹è¯•
+     void testInitialState();
+     void testAutoStartProperty();
+     void testAutoStartSignal();
+     
+     // é…ç½®æŒä¹…åŒ–æµ‹è¯•
+     void testConfigPersistence();
+     void testMultipleInstances();
+     
+     // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
+     void testInvalidConfigValues();
+     void testConfigFileCorruption();
+ 
+ private:
+     ConfigManager *m_configManager;
+     QString m_testConfigPath;
+     
+     void clearTestConfig();
+     void createCorruptedConfig();
+ };
+ 
+ void TestConfigManager::initTestCase()
+ {
+     // è®¾ç½®æµ‹è¯•é…ç½®è·¯å¾„
+     m_testConfigPath = QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/cleanmydeepin_test";
+     QDir().mkpath(m_testConfigPath);
+     
+     // è®¾ç½®æµ‹è¯•ç¯å¢ƒçš„é…ç½®è·¯å¾„
+     QSettings::setPath(QSettings::IniFormat, QSettings::UserScope, m_testConfigPath);
+     
+     qDebug() << "Test config directory:" << m_testConfigPath;
+ }
+ 
+ void TestConfigManager::cleanupTestCase()
+ {
+     // æ¸…ç†æµ‹è¯•é…ç½®ç›®å½•
+     QDir testDir(m_testConfigPath);
+     testDir.removeRecursively();
+ }
+ 
+ void TestConfigManager::init()
+ {
+     clearTestConfig();
+     m_configManager = new ConfigManager(this);
+ }
+ 
+ void TestConfigManager::cleanup()
+ {
+     delete m_configManager;
+     m_configManager = nullptr;
+     clearTestConfig();
+ }
+ 
+ void TestConfigManager::clearTestConfig()
+ {
+     // æ¸…ç†æµ‹è¯•é…ç½®æ–‡ä»¶
+     QSettings settings("CleanMyDeepin", "CleanMyDeepin");
+     settings.clear();
+     settings.sync();
+ }
+ 
+ void TestConfigManager::createCorruptedConfig()
+ {
+     // åˆ›å»ºæŸåçš„é…ç½®æ–‡ä»¶
+     QSettings settings("CleanMyDeepin", "CleanMyDeepin");
+     QString configFile = settings.fileName();
+     
+     QFile file(configFile);
+     if (file.open(QIODevice::WriteOnly)) {
+         file.write("corrupted config data\n[invalid section\nkey=");
+         file.close();
+     }
+ }
+ 
+ void TestConfigManager::testInitialState()
+ {
+     // æµ‹è¯•åˆå§‹çŠ¶æ€
+     // é»˜è®¤æƒ…å†µä¸‹ï¼ŒautoStart åº”è¯¥ä¸º false
+     QCOMPARE(m_configManager->autoStart(), false);
+ }
+ 
+ void TestConfigManager::testAutoStartProperty()
+ {
+     // æµ‹è¯• autoStart å±æ€§çš„è®¾ç½®å’Œè·å–
+     
+     // åˆå§‹å€¼åº”è¯¥ä¸º false
+     QCOMPARE(m_configManager->autoStart(), false);
+     
+     // è®¾ç½®ä¸º true
+     m_configManager->setAutoStart(true);
+     QCOMPARE(m_configManager->autoStart(), true);
+     
+     // è®¾ç½®ä¸º false
+     m_configManager->setAutoStart(false);
+     QCOMPARE(m_configManager->autoStart(), false);
+     
+     // é‡å¤è®¾ç½®ç›¸åŒå€¼
+     m_configManager->setAutoStart(false);
+     QCOMPARE(m_configManager->autoStart(), false);
+     
+     m_configManager->setAutoStart(true);
+     QCOMPARE(m_configManager->autoStart(), true);
+     
+     m_configManager->setAutoStart(true);
+     QCOMPARE(m_configManager->autoStart(), true);
+ }
+ 
+ void TestConfigManager::testAutoStartSignal()
+ {
+     // æµ‹è¯• autoStartChanged ä¿¡å·
+     QSignalSpy autoStartSpy(m_configManager, &ConfigManager::autoStartChanged);
+     
+     // åˆå§‹çŠ¶æ€ï¼Œæ²¡æœ‰ä¿¡å·
+     QCOMPARE(autoStartSpy.count(), 0);
+     
+     // è®¾ç½®ä¸º trueï¼Œåº”è¯¥å‘å°„ä¿¡å·
+     m_configManager->setAutoStart(true);
+     QCOMPARE(autoStartSpy.count(), 1);
+     
+     // è®¾ç½®ä¸ºç›¸åŒå€¼ï¼Œä¸åº”è¯¥å‘å°„ä¿¡å·
+     m_configManager->setAutoStart(true);
+     QCOMPARE(autoStartSpy.count(), 1);
+     
+     // è®¾ç½®ä¸º falseï¼Œåº”è¯¥å‘å°„ä¿¡å·
+     m_configManager->setAutoStart(false);
+     QCOMPARE(autoStartSpy.count(), 2);
+     
+     // å†æ¬¡è®¾ç½®ä¸º falseï¼Œä¸åº”è¯¥å‘å°„ä¿¡å·
+     m_configManager->setAutoStart(false);
+     QCOMPARE(autoStartSpy.count(), 2);
+     
+     // è®¾ç½®ä¸º trueï¼Œåº”è¯¥å‘å°„ä¿¡å·
+     m_configManager->setAutoStart(true);
+     QCOMPARE(autoStartSpy.count(), 3);
+ }
+ 
+ void TestConfigManager::testConfigPersistence()
+ {
+     // æµ‹è¯•é…ç½®çš„æŒä¹…åŒ–
+     
+     // è®¾ç½®é…ç½®å€¼
+     m_configManager->setAutoStart(true);
+     QCOMPARE(m_configManager->autoStart(), true);
+     
+     // åˆ é™¤å½“å‰å®ä¾‹
+     delete m_configManager;
+     m_configManager = nullptr;
+     
+     // åˆ›å»ºæ–°å®ä¾‹ï¼Œåº”è¯¥åŠ è½½ä¹‹å‰ä¿å­˜çš„é…ç½®
+     m_configManager = new ConfigManager(this);
+     QCOMPARE(m_configManager->autoStart(), true);
+     
+     // ä¿®æ”¹é…ç½®
+     m_configManager->setAutoStart(false);
+     QCOMPARE(m_configManager->autoStart(), false);
+     
+     // å†æ¬¡é‡æ–°åˆ›å»ºå®ä¾‹
+     delete m_configManager;
+     m_configManager = new ConfigManager(this);
+     QCOMPARE(m_configManager->autoStart(), false);
+ }
+ 
+ void TestConfigManager::testMultipleInstances()
+ {
+     // æµ‹è¯•å¤šä¸ªå®ä¾‹ä¹‹é—´çš„é…ç½®åŒæ­¥
+     
+     // åˆ›å»ºç¬¬äºŒä¸ªå®ä¾‹
+     ConfigManager *secondManager = new ConfigManager(this);
+     
+     // åˆå§‹çŠ¶æ€åº”è¯¥ç›¸åŒ
+     QCOMPARE(m_configManager->autoStart(), secondManager->autoStart());
+     
+     // åœ¨ç¬¬ä¸€ä¸ªå®ä¾‹ä¸­ä¿®æ”¹é…ç½®
+     m_configManager->setAutoStart(true);
+     
+     // ç¬¬äºŒä¸ªå®ä¾‹åº”è¯¥ä»ç„¶æ˜¯æ—§å€¼ï¼ˆå› ä¸ºæ²¡æœ‰è‡ªåŠ¨åŒæ­¥æœºåˆ¶ï¼‰
+     QCOMPARE(secondManager->autoStart(), false);
+     
+     // åˆ é™¤å¹¶é‡æ–°åˆ›å»ºç¬¬äºŒä¸ªå®ä¾‹ï¼Œåº”è¯¥è·å–æ–°å€¼
+     delete secondManager;
+     secondManager = new ConfigManager(this);
+     QCOMPARE(secondManager->autoStart(), true);
+     
+     // åœ¨ç¬¬äºŒä¸ªå®ä¾‹ä¸­ä¿®æ”¹é…ç½®
+     QSignalSpy firstSpy(m_configManager, &ConfigManager::autoStartChanged);
+     QSignalSpy secondSpy(secondManager, &ConfigManager::autoStartChanged);
+     
+     secondManager->setAutoStart(false);
+     
+     // éªŒè¯ä¿¡å·åªåœ¨ä¿®æ”¹çš„å®ä¾‹ä¸­å‘å°„
+     QCOMPARE(firstSpy.count(), 0);
+     QCOMPARE(secondSpy.count(), 1);
+     
+     // éªŒè¯å€¼
+     QCOMPARE(m_configManager->autoStart(), true);  // ç¬¬ä¸€ä¸ªå®ä¾‹ä¿æŒæ—§å€¼
+     QCOMPARE(secondManager->autoStart(), false);   // ç¬¬äºŒä¸ªå®ä¾‹æ˜¯æ–°å€¼
+     
+     delete secondManager;
+ }
+ 
+ void TestConfigManager::testInvalidConfigValues()
+ {
+     // æµ‹è¯•æ— æ•ˆé…ç½®å€¼çš„å¤„ç†
+     
+     // ç›´æ¥ä¿®æ”¹é…ç½®æ–‡ä»¶ï¼Œè®¾ç½®æ— æ•ˆå€¼
+     QSettings settings("CleanMyDeepin", "CleanMyDeepin");
+     settings.setValue("autoStart", "invalid_boolean_value");
+     settings.sync();
+     
+     // åˆ›å»ºæ–°å®ä¾‹ï¼Œåº”è¯¥ä½¿ç”¨é»˜è®¤å€¼
+     delete m_configManager;
+     m_configManager = new ConfigManager(this);
+     
+     // åº”è¯¥ä½¿ç”¨é»˜è®¤å€¼ false
+     QCOMPARE(m_configManager->autoStart(), false);
+     
+     // è®¾ç½®æœ‰æ•ˆå€¼åº”è¯¥æ­£å¸¸å·¥ä½œ
+     m_configManager->setAutoStart(true);
+     QCOMPARE(m_configManager->autoStart(), true);
+ }
+ 
+ void TestConfigManager::testConfigFileCorruption()
+ {
+     // æµ‹è¯•é…ç½®æ–‡ä»¶æŸåçš„å¤„ç†
+     
+     // åˆ›å»ºæŸåçš„é…ç½®æ–‡ä»¶
+     createCorruptedConfig();
+     
+     // åˆ›å»ºæ–°å®ä¾‹ï¼Œåº”è¯¥èƒ½å¤Ÿå¤„ç†æŸåçš„é…ç½®æ–‡ä»¶
+     delete m_configManager;
+     m_configManager = new ConfigManager(this);
+     
+     // åº”è¯¥ä½¿ç”¨é»˜è®¤å€¼
+     QCOMPARE(m_configManager->autoStart(), false);
+     
+     // è®¾ç½®æ–°å€¼åº”è¯¥æ­£å¸¸å·¥ä½œ
+     QSignalSpy autoStartSpy(m_configManager, &ConfigManager::autoStartChanged);
+     m_configManager->setAutoStart(true);
+     
+     QCOMPARE(autoStartSpy.count(), 1);
+     QCOMPARE(m_configManager->autoStart(), true);
+     
+     // é‡æ–°åˆ›å»ºå®ä¾‹ï¼Œåº”è¯¥èƒ½å¤Ÿæ­£å¸¸åŠ è½½
+     delete m_configManager;
+     m_configManager = new ConfigManager(this);
+     QCOMPARE(m_configManager->autoStart(), true);
+ }
+ 
+ QTEST_MAIN(TestConfigManager)
+ #include "test_configmanager.moc" 
```

---

```diff
- 
+ #include <QtTest/QtTest>
+ #include <QObject>
+ #include <QFile>
+ #include <QTextStream>
+ #include <QDir>
+ #include <QStandardPaths>
+ #include <QLoggingCategory>
+ #include <QDebug>
+ #include "logger.h"
+ 
+ class TestLogger : public QObject
+ {
+     Q_OBJECT
+ 
+ private slots:
+     void initTestCase();
+     void cleanupTestCase();
+     void init();
+     void cleanup();
+ 
+     // åŸºç¡€åŠŸèƒ½æµ‹è¯•
+     void testLoggerInit();
+     void testInfoLogging();
+     void testWarnLogging();
+     void testErrorLogging();
+     
+     // æ—¥å¿—æ ¼å¼æµ‹è¯•
+     void testLogFormat();
+     void testLogTimestamp();
+     void testLogLevels();
+     
+     // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
+     void testEmptyMessage();
+     void testLongMessage();
+     void testSpecialCharacters();
+     void testConcurrentLogging();
+     
+     // æ–‡ä»¶æ“ä½œæµ‹è¯•
+     void testLogFileCreation();
+     void testLogFilePermissions();
+ 
+ private:
+     QString m_testLogDir;
+     QString m_originalLogFile;
+     
+     void redirectLogOutput();
+     void restoreLogOutput();
+     QString readLogFile();
+     void clearLogFile();
+ };
+ 
+ void TestLogger::initTestCase()
+ {
+     // è®¾ç½®æµ‹è¯•æ—¥å¿—ç›®å½•
+     m_testLogDir = QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/cleanmydeepin_test_logs";
+     QDir().mkpath(m_testLogDir);
+     
+     qDebug() << "Test log directory:" << m_testLogDir;
+ }
+ 
+ void TestLogger::cleanupTestCase()
+ {
+     // æ¸…ç†æµ‹è¯•æ—¥å¿—ç›®å½•
+     QDir testDir(m_testLogDir);
+     testDir.removeRecursively();
+ }
+ 
+ void TestLogger::init()
+ {
+     // æ¯ä¸ªæµ‹è¯•å‰åˆå§‹åŒ–
+     redirectLogOutput();
+     Logger::init();
+ }
+ 
+ void TestLogger::cleanup()
+ {
+     // æ¯ä¸ªæµ‹è¯•åæ¸…ç†
+     clearLogFile();
+     restoreLogOutput();
+ }
+ 
+ void TestLogger::redirectLogOutput()
+ {
+     // é‡å®šå‘æ—¥å¿—è¾“å‡ºåˆ°æµ‹è¯•æ–‡ä»¶
+     // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ ¹æ® Logger çš„å…·ä½“å®ç°æ¥è°ƒæ•´
+     // å¦‚æœ Logger ä½¿ç”¨æ–‡ä»¶è¾“å‡ºï¼Œéœ€è¦è®¾ç½®æµ‹è¯•æ–‡ä»¶è·¯å¾„
+ }
+ 
+ void TestLogger::restoreLogOutput()
+ {
+     // æ¢å¤åŸå§‹æ—¥å¿—è¾“å‡º
+ }
+ 
+ QString TestLogger::readLogFile()
+ {
+     // è¯»å–æ—¥å¿—æ–‡ä»¶å†…å®¹
+     // è¿™é‡Œéœ€è¦æ ¹æ® Logger çš„å…·ä½“å®ç°æ¥ç¡®å®šæ—¥å¿—æ–‡ä»¶ä½ç½®
+     QString logFilePath = m_testLogDir + "/cleanmydeepin.log";
+     
+     QFile logFile(logFilePath);
+     if (logFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
+         QTextStream stream(&logFile);
+         return stream.readAll();
+     }
+     
+     return QString();
+ }
+ 
+ void TestLogger::clearLogFile()
+ {
+     // æ¸…ç©ºæ—¥å¿—æ–‡ä»¶
+     QString logFilePath = m_testLogDir + "/cleanmydeepin.log";
+     QFile logFile(logFilePath);
+     if (logFile.exists()) {
+         logFile.remove();
+     }
+ }
+ 
+ void TestLogger::testLoggerInit()
+ {
+     // æµ‹è¯• Logger åˆå§‹åŒ–
+     // Logger::init() åº”è¯¥åœ¨ init() ä¸­å·²ç»è°ƒç”¨
+     
+     // éªŒè¯åˆå§‹åŒ–åå¯ä»¥æ­£å¸¸è®°å½•æ—¥å¿—
+     Logger::info("Test initialization message");
+     
+     // ç”±äº Logger æ˜¯é™æ€ç±»ï¼Œæˆ‘ä»¬ä¸»è¦éªŒè¯ä¸ä¼šå´©æºƒ
+     QVERIFY(true);
+ }
+ 
+ void TestLogger::testInfoLogging()
+ {
+     // æµ‹è¯•ä¿¡æ¯çº§åˆ«æ—¥å¿—
+     QString testMessage = "This is an info message";
+     
+     // è®°å½•ä¿¡æ¯æ—¥å¿—
+     Logger::info(testMessage);
+     
+     // éªŒè¯æ—¥å¿—å†…å®¹
+     // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ ¹æ® Logger çš„å…·ä½“å®ç°æ¥éªŒè¯
+     // å¦‚æœ Logger è¾“å‡ºåˆ°æ–‡ä»¶ï¼Œéœ€è¦è¯»å–æ–‡ä»¶å†…å®¹
+     // å¦‚æœ Logger è¾“å‡ºåˆ°æ§åˆ¶å°ï¼Œéœ€è¦æ•è·è¾“å‡º
+     
+     // åŸºæœ¬éªŒè¯ï¼šè°ƒç”¨ä¸ä¼šå´©æºƒ
+     QVERIFY(true);
+     
+     // å¦‚æœæœ‰æ—¥å¿—æ–‡ä»¶ï¼Œå¯ä»¥éªŒè¯å†…å®¹
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         QVERIFY(logContent.contains(testMessage));
+         QVERIFY(logContent.contains("INFO") || logContent.contains("info"));
+     }
+ }
+ 
+ void TestLogger::testWarnLogging()
+ {
+     // æµ‹è¯•è­¦å‘Šçº§åˆ«æ—¥å¿—
+     QString testMessage = "This is a warning message";
+     
+     Logger::warn(testMessage);
+     
+     // åŸºæœ¬éªŒè¯
+     QVERIFY(true);
+     
+     // éªŒè¯æ—¥å¿—å†…å®¹
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         QVERIFY(logContent.contains(testMessage));
+         QVERIFY(logContent.contains("WARN") || logContent.contains("warn"));
+     }
+ }
+ 
+ void TestLogger::testErrorLogging()
+ {
+     // æµ‹è¯•é”™è¯¯çº§åˆ«æ—¥å¿—
+     QString testMessage = "This is an error message";
+     
+     Logger::error(testMessage);
+     
+     // åŸºæœ¬éªŒè¯
+     QVERIFY(true);
+     
+     // éªŒè¯æ—¥å¿—å†…å®¹
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         QVERIFY(logContent.contains(testMessage));
+         QVERIFY(logContent.contains("ERROR") || logContent.contains("error"));
+     }
+ }
+ 
+ void TestLogger::testLogFormat()
+ {
+     // æµ‹è¯•æ—¥å¿—æ ¼å¼
+     QString testMessage = "Format test message";
+     
+     Logger::info(testMessage);
+     Logger::warn(testMessage);
+     Logger::error(testMessage);
+     
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         // éªŒè¯æ—¥å¿—åŒ…å«æ¶ˆæ¯å†…å®¹
+         QVERIFY(logContent.contains(testMessage));
+         
+         // éªŒè¯æ—¥å¿—æ ¼å¼ï¼ˆæ—¶é—´æˆ³ã€çº§åˆ«ç­‰ï¼‰
+         // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„æ—¥å¿—æ ¼å¼æ¥éªŒè¯
+         QStringList lines = logContent.split('\n', Qt::SkipEmptyParts);
+         QVERIFY(lines.size() >= 3); // è‡³å°‘æœ‰ä¸‰è¡Œæ—¥å¿—
+         
+         // éªŒè¯æ¯è¡Œéƒ½åŒ…å«åŸºæœ¬ä¿¡æ¯
+         for (const QString &line : lines) {
+             if (line.contains(testMessage)) {
+                 // éªŒè¯åŒ…å«æ—¶é—´æˆ³ï¼ˆå‡è®¾æ ¼å¼åŒ…å«æ•°å­—å’Œå†’å·ï¼‰
+                 QVERIFY(line.contains(QRegularExpression("\\d+:\\d+")));
+             }
+         }
+     }
+ }
+ 
+ void TestLogger::testLogTimestamp()
+ {
+     // æµ‹è¯•æ—¥å¿—æ—¶é—´æˆ³
+     QString testMessage1 = "First message";
+     QString testMessage2 = "Second message";
+     
+     Logger::info(testMessage1);
+     
+     // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿æ—¶é—´æˆ³ä¸åŒ
+     QTest::qWait(10);
+     
+     Logger::info(testMessage2);
+     
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         // éªŒè¯ä¸¤æ¡æ¶ˆæ¯éƒ½å­˜åœ¨
+         QVERIFY(logContent.contains(testMessage1));
+         QVERIFY(logContent.contains(testMessage2));
+         
+         // éªŒè¯æ—¶é—´æˆ³æ ¼å¼
+         QStringList lines = logContent.split('\n', Qt::SkipEmptyParts);
+         for (const QString &line : lines) {
+             if (line.contains(testMessage1) || line.contains(testMessage2)) {
+                 // éªŒè¯åŒ…å«æ—¶é—´ä¿¡æ¯
+                 QVERIFY(line.contains(QRegularExpression("\\d")));
+             }
+         }
+     }
+ }
+ 
+ void TestLogger::testLogLevels()
+ {
+     // æµ‹è¯•ä¸åŒæ—¥å¿—çº§åˆ«
+     Logger::info("Info level test");
+     Logger::warn("Warn level test");
+     Logger::error("Error level test");
+     
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         // éªŒè¯æ‰€æœ‰çº§åˆ«çš„æ—¥å¿—éƒ½è¢«è®°å½•
+         QVERIFY(logContent.contains("Info level test"));
+         QVERIFY(logContent.contains("Warn level test"));
+         QVERIFY(logContent.contains("Error level test"));
+         
+         // éªŒè¯çº§åˆ«æ ‡è¯†
+         QStringList lines = logContent.split('\n', Qt::SkipEmptyParts);
+         bool hasInfo = false, hasWarn = false, hasError = false;
+         
+         for (const QString &line : lines) {
+             if (line.contains("Info level test")) {
+                 hasInfo = true;
+             }
+             if (line.contains("Warn level test")) {
+                 hasWarn = true;
+             }
+             if (line.contains("Error level test")) {
+                 hasError = true;
+             }
+         }
+         
+         QVERIFY(hasInfo);
+         QVERIFY(hasWarn);
+         QVERIFY(hasError);
+     }
+ }
+ 
+ void TestLogger::testEmptyMessage()
+ {
+     // æµ‹è¯•ç©ºæ¶ˆæ¯
+     Logger::info("");
+     Logger::warn(QString());
+     Logger::error("");
+     
+     // åº”è¯¥ä¸ä¼šå´©æºƒ
+     QVERIFY(true);
+     
+     // éªŒè¯ç©ºæ¶ˆæ¯çš„å¤„ç†
+     QString logContent = readLogFile();
+     // ç©ºæ¶ˆæ¯å¯èƒ½è¢«è®°å½•ä¹Ÿå¯èƒ½è¢«å¿½ç•¥ï¼Œå–å†³äºå®ç°
+     // ä¸»è¦éªŒè¯ä¸ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ
+ }
+ 
+ void TestLogger::testLongMessage()
+ {
+     // æµ‹è¯•é•¿æ¶ˆæ¯
+     QString longMessage = QString("Very long message: ").repeated(100) + "End";
+     
+     Logger::info(longMessage);
+     
+     // åº”è¯¥ä¸ä¼šå´©æºƒ
+     QVERIFY(true);
+     
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         // éªŒè¯é•¿æ¶ˆæ¯è¢«æ­£ç¡®è®°å½•
+         QVERIFY(logContent.contains("Very long message"));
+         QVERIFY(logContent.contains("End"));
+     }
+ }
+ 
+ void TestLogger::testSpecialCharacters()
+ {
+     // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
+     QString specialMessage = "Special chars: ä¸­æ–‡ Ã©Ã± Ã± Ã¼ ÃŸ ğŸš€ \n\t\r";
+     
+     Logger::info(specialMessage);
+     
+     // åº”è¯¥ä¸ä¼šå´©æºƒ
+     QVERIFY(true);
+     
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         // éªŒè¯ç‰¹æ®Šå­—ç¬¦è¢«æ­£ç¡®å¤„ç†
+         QVERIFY(logContent.contains("Special chars"));
+         // æ³¨æ„ï¼šæŸäº›ç‰¹æ®Šå­—ç¬¦å¯èƒ½è¢«è½¬ä¹‰æˆ–è¿‡æ»¤
+     }
+ }
+ 
+ void TestLogger::testConcurrentLogging()
+ {
+     // æµ‹è¯•å¹¶å‘æ—¥å¿—è®°å½•
+     const int threadCount = 5;
+     const int messagesPerThread = 10;
+     
+     QList<QThread*> threads;
+     
+     for (int i = 0; i < threadCount; ++i) {
+         QThread *thread = QThread::create([i, messagesPerThread]() {
+             for (int j = 0; j < messagesPerThread; ++j) {
+                 QString message = QString("Thread %1 Message %2").arg(i).arg(j);
+                 Logger::info(message);
+                 
+                 // å°å»¶è¿Ÿæ¨¡æ‹Ÿå®é™…ä½¿ç”¨
+                 QThread::msleep(1);
+             }
+         });
+         
+         threads.append(thread);
+         thread->start();
+     }
+     
+     // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
+     for (QThread *thread : threads) {
+         QVERIFY(thread->wait(5000)); // 5ç§’è¶…æ—¶
+         delete thread;
+     }
+     
+     // éªŒè¯å¹¶å‘æ—¥å¿—è®°å½•
+     QString logContent = readLogFile();
+     if (!logContent.isEmpty()) {
+         // éªŒè¯æ‰€æœ‰çº¿ç¨‹çš„æ¶ˆæ¯éƒ½è¢«è®°å½•
+         for (int i = 0; i < threadCount; ++i) {
+             QString threadPattern = QString("Thread %1").arg(i);
+             QVERIFY(logContent.contains(threadPattern));
+         }
+         
+         // è®¡ç®—æ€»æ¶ˆæ¯æ•°
+         int totalMessages = logContent.split('\n', Qt::SkipEmptyParts).size();
+         QVERIFY(totalMessages >= threadCount * messagesPerThread);
+     }
+ }
+ 
+ void TestLogger::testLogFileCreation()
+ {
+     // æµ‹è¯•æ—¥å¿—æ–‡ä»¶åˆ›å»º
+     QString testMessage = "File creation test";
+     
+     // ç¡®ä¿æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨
+     clearLogFile();
+     
+     // è®°å½•æ—¥å¿—
+     Logger::info(testMessage);
+     
+     // éªŒè¯æ—¥å¿—æ–‡ä»¶æ˜¯å¦è¢«åˆ›å»º
+     QString logFilePath = m_testLogDir + "/cleanmydeepin.log";
+     
+     // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ ¹æ® Logger çš„å…·ä½“å®ç°æ¥ç¡®å®šæ–‡ä»¶è·¯å¾„
+     // å¦‚æœ Logger ä¸ä½¿ç”¨æ–‡ä»¶è¾“å‡ºï¼Œè¿™ä¸ªæµ‹è¯•å¯èƒ½éœ€è¦è°ƒæ•´
+     
+     // åŸºæœ¬éªŒè¯ï¼šæ—¥å¿—è°ƒç”¨ä¸ä¼šå´©æºƒ
+     QVERIFY(true);
+ }
+ 
+ void TestLogger::testLogFilePermissions()
+ {
+     // æµ‹è¯•æ—¥å¿—æ–‡ä»¶æƒé™
+     QString testMessage = "Permission test";
+     
+     Logger::info(testMessage);
+     
+     QString logFilePath = m_testLogDir + "/cleanmydeepin.log";
+     QFile logFile(logFilePath);
+     
+     if (logFile.exists()) {
+         // éªŒè¯æ–‡ä»¶å¯è¯»
+         QVERIFY(logFile.open(QIODevice::ReadOnly));
+         logFile.close();
+         
+         // éªŒè¯æ–‡ä»¶æƒé™
+         QFileInfo fileInfo(logFile);
+         QVERIFY(fileInfo.isReadable());
+         QVERIFY(fileInfo.isWritable());
+     }
+     
+     // åŸºæœ¬éªŒè¯
+     QVERIFY(true);
+ }
+ 
+ QTEST_MAIN(TestLogger)
+ #include "test_logger.moc" 
```

---

Cancelled

---

_**User**_

ç»§ç»­å®Œæˆ

---

_**Assistant**_



---



---



---

